{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": None,
   "id": "e9cbb860-da7f-433d-b6a6-5066df2e602f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#!/usr/bin/env python3\n",
    "\"\"\"\n",
    "excel_merge_app.py\n",
    "\n",
    "Excel Merge Tool by Huzaifa\n",
    "Single-file desktop GUI (Tkinter) application that:\n",
    " - Allows selecting multiple Excel files (.xlsx and .xls)\n",
    " - Merges them into a single pandas DataFrame\n",
    " - Shows preview (first 10 rows) and counts\n",
    " - Shows a full paginated view (default page size 100)\n",
    " - Saves master file and saves a timestamped backup in backups/\n",
    " - Sends master file via email (Gmail via yagmail preferred, or generic SMTP)\n",
    " - Optional Watch Folder (uses watchdog if installed)\n",
    " - Background threads for merge and email so UI remains responsive\n",
    " - Logging to excel_merge_app.log\n",
    "\n",
    "Run: python excel_merge_app.py\n",
    "\"\"\"\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import json\n",
    "import threading\n",
    "import queue\n",
    "import time\n",
    "import math\n",
    "import re\n",
    "import logging\n",
    "import traceback\n",
    "from datetime import datetime\n",
    "\n",
    "try:\n",
    "    import tkinter as tk\n",
    "    from tkinter import ttk, filedialog, messagebox, simpledialog\n",
    "except Exception as e:\n",
    "    print(\"tkinter is required to run this app. On Linux install python3-tk.\")\n",
    "    raise\n",
    "\n",
    "# Data & emailing dependencies\n",
    "try:\n",
    "    import pandas as pd\n",
    "except Exception as e:\n",
    "    message = (\"pandas is required. Install via: pip install pandas openpyxl xlrd \"\n",
    "               \"and other requirements from requirements.txt\")\n",
    "    raise ImportError(message)\n",
    "\n",
    "# Optional yagmail & watchdog (we handle gracefully if missing)\n",
    "try:\n",
    "    import yagmail\n",
    "except Exception:\n",
    "    yagmail = None\n",
    "\n",
    "try:\n",
    "    from watchdog.observers import Observer\n",
    "    from watchdog.events import FileSystemEventHandler\n",
    "except Exception:\n",
    "    Observer = None\n",
    "    FileSystemEventHandler = object  # fallback base\n",
    "\n",
    "# For generic smtp fallback\n",
    "import smtplib\n",
    "from email.message import EmailMessage\n",
    "\n",
    "# ----------------------------\n",
    "# Logging configuration\n",
    "# ----------------------------\n",
    "LOG_FILE = \"excel_merge_app.log\"\n",
    "logging.basicConfig(\n",
    "    level=logging.INFO,\n",
    "    format=\"%(asctime)s - %(levelname)s - %(message)s\",\n",
    "    handlers=[\n",
    "        logging.FileHandler(LOG_FILE, encoding=\"utf-8\"),\n",
    "        logging.StreamHandler(sys.stdout)\n",
    "    ]\n",
    ")\n",
    "logger = logging.getLogger(\"ExcelMergeApp\")\n",
    "\n",
    "# ----------------------------\n",
    "# Constants & defaults\n",
    "# ----------------------------\n",
    "CONFIG_FILE = \"config.json\"\n",
    "CONFIG_TEMPLATE = \"config_template.json\"\n",
    "BACKUPS_DIR = \"backups\"\n",
    "DEFAULT_PAGE_SIZE = 100\n",
    "PREVIEW_ROWS = 10\n",
    "EMAIL_SUBJECT = \"Merged Excel - Master File\"\n",
    "EMAIL_BODY = \"Attached is the merged master Excel file.\"\n",
    "\n",
    "EMAIL_REGEX = re.compile(r\"^[^@]+@[^@]+\\.[^@]+$\")  # simple validation\n",
    "\n",
    "# ----------------------------\n",
    "# Helper functions\n",
    "# ----------------------------\n",
    "def timestamp_suffix():\n",
    "    return datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n",
    "\n",
    "\n",
    "def create_backups_folder():\n",
    "    if not os.path.exists(BACKUPS_DIR):\n",
    "        os.makedirs(BACKUPS_DIR, exist_ok=True)\n",
    "\n",
    "\n",
    "def open_folder(path):\n",
    "    \"\"\"Open a folder in OS file browser (Windows/macOS/Linux).\"\"\"\n",
    "    try:\n",
    "        if sys.platform.startswith(\"win\"):\n",
    "            os.startfile(path)\n",
    "        elif sys.platform == \"darwin\":\n",
    "            subprocess.run([\"open\", path])\n",
    "        else:\n",
    "            # Linux\n",
    "            import subprocess\n",
    "            subprocess.run([\"xdg-open\", path])\n",
    "    except Exception as e:\n",
    "        logger.exception(\"Failed to open folder: %s\", e)\n",
    "        messagebox.showinfo(\"Open Folder\", f\"Folder: {path}\")\n",
    "\n",
    "\n",
    "def format_count(n):\n",
    "    return f\"{n:,}\"\n",
    "\n",
    "\n",
    "def safe_save_dataframe_to_excel(df: pd.DataFrame, path: str):\n",
    "    \"\"\"Save dataframe to an excel file safely (engine openpyxl).\"\"\"\n",
    "    try:\n",
    "        df.to_excel(path, index=False, engine=\"openpyxl\")\n",
    "    except Exception as e:\n",
    "        # Try fallback (pandas default)\n",
    "        df.to_excel(path, index=False)\n",
    "\n",
    "\n",
    "# ----------------------------\n",
    "# Config management\n",
    "# ----------------------------\n",
    "def load_config():\n",
    "    \"\"\"Load configuration from config.json. If not exists, return defaults.\"\"\"\n",
    "    defaults = {\n",
    "        \"use_gmail\": True,\n",
    "        \"sender_email\": \"\",\n",
    "        \"app_password\": \"\",\n",
    "        \"save_password\": False,\n",
    "        \"smtp\": {\n",
    "            \"host\": \"\",\n",
    "            \"port\": 587,\n",
    "            \"username\": \"\",\n",
    "            \"password\": \"\",\n",
    "            \"use_tls\": True,\n",
    "            \"use_ssl\": False\n",
    "        },\n",
    "        \"backups_enabled\": True,\n",
    "        \"watch_folder\": {\n",
    "            \"enabled\": False,\n",
    "            \"path\": \"\",\n",
    "            \"auto_email_on_watch\": False,\n",
    "            \"auto_email_recipients\": \"\"\n",
    "        },\n",
    "        \"page_size_default\": DEFAULT_PAGE_SIZE\n",
    "    }\n",
    "    if os.path.exists(CONFIG_FILE):\n",
    "        try:\n",
    "            with open(CONFIG_FILE, \"r\", encoding=\"utf-8\") as f:\n",
    "                cfg = json.load(f)\n",
    "            # Merge with defaults to ensure keys exist\n",
    "            merged = defaults.copy()\n",
    "            merged.update(cfg)\n",
    "            # merge nested smtp and watch_folder\n",
    "            merged[\"smtp\"] = {**defaults[\"smtp\"], **cfg.get(\"smtp\", {})}\n",
    "            merged[\"watch_folder\"] = {**defaults[\"watch_folder\"], **cfg.get(\"watch_folder\", {})}\n",
    "            return merged\n",
    "        except Exception as e:\n",
    "            logger.exception(\"Error loading config.json: %s\", e)\n",
    "            return defaults\n",
    "    else:\n",
    "        return defaults\n",
    "\n",
    "\n",
    "def save_config(cfg: dict):\n",
    "    try:\n",
    "        with open(CONFIG_FILE, \"w\", encoding=\"utf-8\") as f:\n",
    "            json.dump(cfg, f, indent=2)\n",
    "        logger.info(\"Configuration saved to %s\", CONFIG_FILE)\n",
    "    except Exception as e:\n",
    "        logger.exception(\"Error saving config: %s\", e)\n",
    "\n",
    "\n",
    "# ----------------------------\n",
    "# Watchdog handler (if available)\n",
    "# ----------------------------\n",
    "class ExcelWatchHandler(FileSystemEventHandler):\n",
    "    \"\"\"Handles filesystem events for watch folder. Debounces rapid events.\"\"\"\n",
    "\n",
    "    def __init__(self, app, debounce_secs=1.0):\n",
    "        super().__init__()\n",
    "        self.app = app\n",
    "        self.debounce_secs = debounce_secs\n",
    "        self.last_event_time = {}\n",
    "        self.lock = threading.Lock()\n",
    "\n",
    "    def should_handle(self, path):\n",
    "        lower = path.lower()\n",
    "        return lower.endswith(\".xlsx\") or lower.endswith(\".xls\")\n",
    "\n",
    "    def _debounced(self, path):\n",
    "        with self.lock:\n",
    "            now = time.time()\n",
    "            last = self.last_event_time.get(path, 0)\n",
    "            if now - last < self.debounce_secs:\n",
    "                return False\n",
    "            self.last_event_time[path] = now\n",
    "            return True\n",
    "\n",
    "    def on_created(self, event):\n",
    "        if not event.is_directory and self.should_handle(event.src_path):\n",
    "            if self._debounced(event.src_path):\n",
    "                logger.info(\"Watch: created %s\", event.src_path)\n",
    "                self.app.queue.put((\"watch_event\", event.src_path))\n",
    "\n",
    "    def on_modified(self, event):\n",
    "        if not event.is_directory and self.should_handle(event.src_path):\n",
    "            if self._debounced(event.src_path):\n",
    "                logger.info(\"Watch: modified %s\", event.src_path)\n",
    "                self.app.queue.put((\"watch_event\", event.src_path))\n",
    "\n",
    "\n",
    "# ----------------------------\n",
    "# Main App Class\n",
    "# ----------------------------\n",
    "class ExcelMergeApp(tk.Tk):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        self.title(\"Excel Merge Tool by Huzaifa\")\n",
    "        self.geometry(\"1100x700\")\n",
    "        self.minsize(900, 600)\n",
    "\n",
    "        # Application state\n",
    "        self.selected_files = []         # list[str]\n",
    "        self.master_df = None            # pandas.DataFrame\n",
    "        self.queue = queue.Queue()       # thread -> main UI queue\n",
    "        self.config = load_config()\n",
    "        self.watch_observer = None\n",
    "        self.watch_handler = None\n",
    "        self.watch_thread = None\n",
    "        self._watching = False\n",
    "\n",
    "        # UI elements references\n",
    "        self.progress = None\n",
    "        self.status_label = None\n",
    "        self.counts_label = None\n",
    "        self.preview_tree = None\n",
    "        self.last_action_label = None\n",
    "        self.page_size_var = tk.IntVar(value=self.config.get(\"page_size_default\", DEFAULT_PAGE_SIZE))\n",
    "\n",
    "        # Setup UI\n",
    "        self.create_widgets()\n",
    "\n",
    "        # Start queue processor\n",
    "        self.after(150, self._process_queue)\n",
    "\n",
    "        # If config says to enable watch folder on startup, start it\n",
    "        if self.config.get(\"watch_folder\", {}).get(\"enabled\", False):\n",
    "            watch_path = self.config[\"watch_folder\"].get(\"path\", \"\")\n",
    "            if watch_path and Observer:\n",
    "                try:\n",
    "                    self.start_watch(watch_path)\n",
    "                except Exception as ex:\n",
    "                    logger.exception(\"Could not start watch on startup: %s\", ex)\n",
    "\n",
    "    # ----------------------------\n",
    "    # UI creation\n",
    "    # ----------------------------\n",
    "    def create_widgets(self):\n",
    "        # Top frame with buttons\n",
    "        top_frame = ttk.Frame(self)\n",
    "        top_frame.pack(side=\"top\", fill=\"x\", padx=8, pady=6)\n",
    "\n",
    "        btn_select = ttk.Button(top_frame, text=\"Select Files\", command=self.select_files)\n",
    "        btn_select.pack(side=\"left\", padx=4)\n",
    "\n",
    "        # Watch folder: toggle + choose\n",
    "        self.watch_var = tk.BooleanVar(value=self.config.get(\"watch_folder\", {}).get(\"enabled\", False))\n",
    "        self.watch_toggle = ttk.Checkbutton(top_frame, text=\"Watch Folder\", variable=self.watch_var, command=self.on_watch_toggle)\n",
    "        self.watch_toggle.pack(side=\"left\", padx=(8,0))\n",
    "\n",
    "        btn_choose_watch = ttk.Button(top_frame, text=\"Choose Watch Folder\", command=self.choose_watch_folder)\n",
    "        btn_choose_watch.pack(side=\"left\", padx=4)\n",
    "\n",
    "        btn_merge = ttk.Button(top_frame, text=\"Merge Now\", command=self.merge_now)\n",
    "        btn_merge.pack(side=\"left\", padx=8)\n",
    "\n",
    "        btn_save = ttk.Button(top_frame, text=\"Save\", command=self.save_master)\n",
    "        btn_save.pack(side=\"left\", padx=8)\n",
    "\n",
    "        btn_save_email = ttk.Button(top_frame, text=\"Save & Email\", command=self.save_and_email)\n",
    "        btn_save_email.pack(side=\"left\", padx=8)\n",
    "\n",
    "        btn_settings = ttk.Button(top_frame, text=\"Settings ⚙\", command=self.open_settings_dialog)\n",
    "        btn_settings.pack(side=\"right\", padx=4)\n",
    "\n",
    "        # Middle: Status area with spinner + textual status + counts\n",
    "        status_frame = ttk.Frame(self)\n",
    "        status_frame.pack(side=\"top\", fill=\"x\", padx=8, pady=6)\n",
    "\n",
    "        self.progress = ttk.Progressbar(status_frame, mode=\"indeterminate\")\n",
    "        self.progress.pack(side=\"left\", padx=(0,6))\n",
    "        # don't start yet\n",
    "\n",
    "        self.status_label = ttk.Label(status_frame, text=\"Ready.\")\n",
    "        self.status_label.pack(side=\"left\", padx=6)\n",
    "\n",
    "        # counts on right\n",
    "        self.counts_label = ttk.Label(status_frame, text=\"Files: 0 | Rows: 0 | Cols: 0\")\n",
    "        self.counts_label.pack(side=\"right\", padx=6)\n",
    "\n",
    "        # Preview area\n",
    "        preview_frame = ttk.LabelFrame(self, text=f\"Preview (first {PREVIEW_ROWS} rows)\")\n",
    "        preview_frame.pack(side=\"top\", fill=\"both\", expand=True, padx=8, pady=6)\n",
    "\n",
    "        # Treeview with scrollbar\n",
    "        tv_frame = ttk.Frame(preview_frame)\n",
    "        tv_frame.pack(fill=\"both\", expand=True)\n",
    "\n",
    "        self.preview_tree = ttk.Treeview(tv_frame, show=\"headings\")\n",
    "        self.preview_tree.pack(side=\"left\", fill=\"both\", expand=True)\n",
    "\n",
    "        vsb = ttk.Scrollbar(tv_frame, orient=\"vertical\", command=self.preview_tree.yview)\n",
    "        vsb.pack(side=\"right\", fill=\"y\")\n",
    "        self.preview_tree.configure(yscrollcommand=vsb.set)\n",
    "\n",
    "        # View full merged button & page size\n",
    "        controls_frame = ttk.Frame(self)\n",
    "        controls_frame.pack(side=\"top\", fill=\"x\", padx=8, pady=(0,8))\n",
    "\n",
    "        view_full_btn = ttk.Button(controls_frame, text=\"View Full Merged (Open Window)\", command=self.open_full_view)\n",
    "        view_full_btn.pack(side=\"left\")\n",
    "\n",
    "        ttk.Label(controls_frame, text=\"Page size:\").pack(side=\"left\", padx=(12,2))\n",
    "        self.page_size_spin = ttk.Spinbox(controls_frame, from_=10, to=5000, textvariable=self.page_size_var, width=8)\n",
    "        self.page_size_spin.pack(side=\"left\", padx=(0,6))\n",
    "\n",
    "        # Footer: last action + open backups folder\n",
    "        footer = ttk.Frame(self)\n",
    "        footer.pack(side=\"bottom\", fill=\"x\", padx=8, pady=6)\n",
    "\n",
    "        self.last_action_label = ttk.Label(footer, text=\"Last action: none\")\n",
    "        self.last_action_label.pack(side=\"left\")\n",
    "\n",
    "        open_backups_btn = ttk.Button(footer, text=\"Open backups folder\", command=self.open_backups_folder)\n",
    "        open_backups_btn.pack(side=\"right\")\n",
    "\n",
    "    # ----------------------------\n",
    "    # Queue processing to update UI from worker threads\n",
    "    # ----------------------------\n",
    "    def _process_queue(self):\n",
    "        \"\"\"Process messages from worker threads.\"\"\"\n",
    "        try:\n",
    "            while True:\n",
    "                item = self.queue.get_nowait()\n",
    "                if not item:\n",
    "                    continue\n",
    "                tag = item[0]\n",
    "                data = item[1] if len(item) > 1 else None\n",
    "\n",
    "                if tag == \"status\":\n",
    "                    self.status_label.config(text=str(data))\n",
    "                elif tag == \"start_spinner\":\n",
    "                    try:\n",
    "                        self.progress.start(10)\n",
    "                        self.progress.pack(side=\"left\", padx=(0,6))\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                elif tag == \"stop_spinner\":\n",
    "                    try:\n",
    "                        self.progress.stop()\n",
    "                        self.progress.pack_forget()\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                elif tag == \"merged\":\n",
    "                    df = data\n",
    "                    self.on_merge_finished(df)\n",
    "                elif tag == \"error\":\n",
    "                    msg = data\n",
    "                    logger.error(\"Worker error: %s\", msg)\n",
    "                    messagebox.showerror(\"Error\", str(msg))\n",
    "                    self.status_label.config(text=\"Error occurred.\")\n",
    "                elif tag == \"email_status\":\n",
    "                    self.status_label.config(text=str(data))\n",
    "                elif tag == \"email_result\":\n",
    "                    success_count, failed = data\n",
    "                    # Stop spinner\n",
    "                    try:\n",
    "                        self.progress.stop()\n",
    "                        self.progress.pack_forget()\n",
    "                    except Exception:\n",
    "                        pass\n",
    "                    if failed:\n",
    "                        messagebox.showwarning(\"Email Result\", f\"Email sent to {success_count} recipients. Failed for: {', '.join(failed)}\")\n",
    "                        self.status_label.config(text=f\"Email completed with failures.\")\n",
    "                    else:\n",
    "                        messagebox.showinfo(\"Email Result\", f\"Email sent to {success_count} recipients.\")\n",
    "                        self.status_label.config(text=f\"Email sent to {success_count} recipients.\")\n",
    "                    logger.info(\"Email result: sent=%d failed=%s\", success_count, failed)\n",
    "                elif tag == \"watch_event\":\n",
    "                    path = data\n",
    "                    self.handle_watch_event(path)\n",
    "                else:\n",
    "                    logger.debug(\"Queue unknown tag: %s\", tag)\n",
    "        except queue.Empty:\n",
    "            pass\n",
    "        # schedule next poll\n",
    "        self.after(150, self._process_queue)\n",
    "\n",
    "    # ----------------------------\n",
    "    # File selection & merge\n",
    "    # ----------------------------\n",
    "    def select_files(self):\n",
    "        paths = filedialog.askopenfilenames(title=\"Select Excel files\", filetypes=[(\"Excel files\", \"*.xlsx *.xls\"), (\"All files\", \"*.*\")])\n",
    "        if paths:\n",
    "            self.selected_files = list(paths)\n",
    "            self.status_label.config(text=f\"{len(self.selected_files)} files selected\")\n",
    "            self.counts_label.config(text=f\"Files: {len(self.selected_files)} | Rows: 0 | Cols: 0\")\n",
    "            logger.info(\"Selected files: %s\", self.selected_files)\n",
    "        else:\n",
    "            self.status_label.config(text=\"No files selected\")\n",
    "\n",
    "    def merge_now(self):\n",
    "        if not self.selected_files:\n",
    "            messagebox.showinfo(\"No files\", \"Please select at least one Excel file first.\")\n",
    "            return\n",
    "        # Start worker thread to merge\n",
    "        t = threading.Thread(target=self._merge_worker, args=(list(self.selected_files),), daemon=True)\n",
    "        t.start()\n",
    "\n",
    "    def _merge_worker(self, files):\n",
    "        \"\"\"Worker that reads each file and merges them. Sends progress to queue.\"\"\"\n",
    "        self.queue.put((\"start_spinner\",))\n",
    "        total_files = len(files)\n",
    "        logger.info(\"Merge started for %d files\", total_files)\n",
    "        dfs = []\n",
    "        read_counts = []\n",
    "        try:\n",
    "            self.queue.put((\"status\", f\"Starting merge of {total_files} files...\"))\n",
    "            for i, fpath in enumerate(files, start=1):\n",
    "                basename = os.path.basename(fpath)\n",
    "                self.queue.put((\"status\", f\"Reading file {i}/{total_files}: {basename}\"))\n",
    "                logger.info(\"Reading file %s (%d/%d)\", basename, i, total_files)\n",
    "                try:\n",
    "                    # choose engine by extension\n",
    "                    if fpath.lower().endswith(\".xls\"):\n",
    "                        # .xls uses xlrd (older), ensure xlrd installed\n",
    "                        df = pd.read_excel(fpath, engine=\"xlrd\")\n",
    "                    else:\n",
    "                        df = pd.read_excel(fpath, engine=\"openpyxl\")\n",
    "                except Exception as e:\n",
    "                    # If reading fails, log and inform UI; continue to next file (or abort?)\n",
    "                    msg = f\"Failed to read {basename}: {e}\"\n",
    "                    logger.exception(msg)\n",
    "                    self.queue.put((\"error\", msg))\n",
    "                    self.queue.put((\"stop_spinner\",))\n",
    "                    return\n",
    "                dfs.append(df)\n",
    "                read_counts.append(len(df))\n",
    "                self.queue.put((\"status\", f\"Read {len(df):,} rows from {basename}\"))\n",
    "            if not dfs:\n",
    "                self.queue.put((\"error\", \"No valid dataframes extracted from selected files.\"))\n",
    "                self.queue.put((\"stop_spinner\",))\n",
    "                return\n",
    "\n",
    "            # Concatenate\n",
    "            self.queue.put((\"status\", \"Concatenating data...\"))\n",
    "            try:\n",
    "                master = pd.concat(dfs, ignore_index=True, sort=False)\n",
    "            except Exception as e:\n",
    "                # Try more robust concat attempt\n",
    "                logger.exception(\"Concat error: %s\", e)\n",
    "                # Try to union columns carefully\n",
    "                master = pd.DataFrame()\n",
    "                for df in dfs:\n",
    "                    master = pd.concat([master, df], ignore_index=True, sort=False)\n",
    "            self.master_df = master\n",
    "            logger.info(\"Merge finished: total rows=%d cols=%d from %d files\", master.shape[0], master.shape[1], total_files)\n",
    "            # Send merged to main thread\n",
    "            self.queue.put((\"merged\", master))\n",
    "            self.queue.put((\"stop_spinner\",))\n",
    "        except Exception as e:\n",
    "            logger.exception(\"Unexpected error during merge: %s\", e)\n",
    "            self.queue.put((\"error\", f\"Unexpected error: {e}\"))\n",
    "            self.queue.put((\"stop_spinner\",))\n",
    "\n",
    "    def on_merge_finished(self, df):\n",
    "        \"\"\"Update UI after merge completes.\"\"\"\n",
    "        rows, cols = df.shape\n",
    "        files_count = len(self.selected_files)\n",
    "        self.counts_label.config(text=f\"Files: {files_count} | Rows: {format_count(rows)} | Cols: {cols}\")\n",
    "        self.status_label.config(text=f\"Merged {files_count} files: {format_count(rows)} rows, {cols} cols.\")\n",
    "        self.last_action_label.config(text=f\"Last action: merged {files_count} files at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n",
    "        logger.info(\"Merge updated UI: rows=%d cols=%d files=%d\", rows, cols, files_count)\n",
    "        # Show preview\n",
    "        self.show_preview(df.head(PREVIEW_ROWS))\n",
    "\n",
    "    # ----------------------------\n",
    "    # Preview display\n",
    "    # ----------------------------\n",
    "    def show_preview(self, df_preview: pd.DataFrame):\n",
    "        \"\"\"Populate the preview treeview with df_preview (small).\"\"\"\n",
    "        # Clear existing\n",
    "        tree = self.preview_tree\n",
    "        tree.delete(*tree.get_children())\n",
    "        # Clear columns\n",
    "        for col in tree[\"columns\"]:\n",
    "            tree.heading(col, text=\"\")\n",
    "        tree[\"columns\"] = list(df_preview.columns)\n",
    "        # Configure headings\n",
    "        for col in df_preview.columns:\n",
    "            tree.heading(col, text=str(col))\n",
    "            # width estimation\n",
    "            tree.column(col, width=120, anchor=\"w\", stretch=True)\n",
    "        # Insert rows\n",
    "        for idx, row in df_preview.iterrows():\n",
    "            vals = [str(row.get(c, \"\")) for c in df_preview.columns]\n",
    "            tree.insert(\"\", \"end\", values=vals)\n",
    "\n",
    "    # ----------------------------\n",
    "    # Full paginated view window\n",
    "    # ----------------------------\n",
    "    def open_full_view(self):\n",
    "        if self.master_df is None:\n",
    "            messagebox.showinfo(\"No data\", \"No merged master file available. Merge files first.\")\n",
    "            return\n",
    "        window = tk.Toplevel(self)\n",
    "        window.title(\"Full Merged View - Paginated\")\n",
    "        window.geometry(\"1000x600\")\n",
    "\n",
    "        page_size = tk.IntVar(value=int(self.page_size_var.get()))\n",
    "        current_page = tk.IntVar(value=1)\n",
    "        total_rows = len(self.master_df)\n",
    "        total_pages = max(1, math.ceil(total_rows / page_size.get()))\n",
    "\n",
    "        # header controls\n",
    "        header = ttk.Frame(window)\n",
    "        header.pack(side=\"top\", fill=\"x\", padx=6, pady=6)\n",
    "\n",
    "        ttk.Label(header, text=f\"Total rows: {format_count(total_rows)}\").pack(side=\"left\", padx=(0,12))\n",
    "        lbl_page_info = ttk.Label(header, text=f\"Page {current_page.get()} / {total_pages}\")\n",
    "        lbl_page_info.pack(side=\"right\", padx=6)\n",
    "\n",
    "        ttk.Label(header, text=\"Page size:\").pack(side=\"left\", padx=(12,2))\n",
    "        page_size_spin = ttk.Spinbox(header, from_=10, to=10000, textvariable=page_size, width=8)\n",
    "        page_size_spin.pack(side=\"left\", padx=(0,6))\n",
    "\n",
    "        # Treeview\n",
    "        tv_frame = ttk.Frame(window)\n",
    "        tv_frame.pack(fill=\"both\", expand=True, padx=6, pady=6)\n",
    "\n",
    "        tree = ttk.Treeview(tv_frame, show=\"headings\")\n",
    "        tree.pack(side=\"left\", fill=\"both\", expand=True)\n",
    "\n",
    "        vsb = ttk.Scrollbar(tv_frame, orient=\"vertical\", command=tree.yview)\n",
    "        vsb.pack(side=\"right\", fill=\"y\")\n",
    "        tree.configure(yscrollcommand=vsb.set)\n",
    "\n",
    "        # pagination functions\n",
    "        def display_page(page):\n",
    "            nonlocal total_pages, total_rows\n",
    "            ps = int(page_size.get())\n",
    "            total_pages = max(1, math.ceil(total_rows / ps))\n",
    "            current_page.set(max(1, min(page, total_pages)))\n",
    "            start = (current_page.get() - 1) * ps\n",
    "            end = min(total_rows, start + ps)\n",
    "            subset = self.master_df.iloc[start:end]\n",
    "            # rebuild tree columns\n",
    "            tree.delete(*tree.get_children())\n",
    "            tree[\"columns\"] = list(subset.columns)\n",
    "            for col in subset.columns:\n",
    "                tree.heading(col, text=str(col))\n",
    "                tree.column(col, width=120, anchor=\"w\", stretch=True)\n",
    "            # insert rows\n",
    "            for i, row in subset.iterrows():\n",
    "                vals = [str(row.get(c, \"\")) for c in subset.columns]\n",
    "                tree.insert(\"\", \"end\", values=vals)\n",
    "            lbl_page_info.config(text=f\"Page {current_page.get()} / {total_pages}\")\n",
    "\n",
    "        def on_prev():\n",
    "            display_page(current_page.get() - 1)\n",
    "\n",
    "        def on_next():\n",
    "            display_page(current_page.get() + 1)\n",
    "\n",
    "        def on_jump():\n",
    "            try:\n",
    "                p = int(jump_entry.get())\n",
    "                display_page(p)\n",
    "            except Exception:\n",
    "                messagebox.showwarning(\"Invalid\", \"Please enter a valid page number.\")\n",
    "\n",
    "        # bottom controls\n",
    "        ctrl = ttk.Frame(window)\n",
    "        ctrl.pack(side=\"bottom\", fill=\"x\", padx=6, pady=6)\n",
    "        btn_prev = ttk.Button(ctrl, text=\"Prev\", command=on_prev)\n",
    "        btn_prev.pack(side=\"left\", padx=4)\n",
    "        btn_next = ttk.Button(ctrl, text=\"Next\", command=on_next)\n",
    "        btn_next.pack(side=\"left\", padx=4)\n",
    "        ttk.Label(ctrl, text=\"Jump to page:\").pack(side=\"left\", padx=(12,4))\n",
    "        jump_entry = ttk.Entry(ctrl, width=8)\n",
    "        jump_entry.pack(side=\"left\")\n",
    "        ttk.Button(ctrl, text=\"Go\", command=on_jump).pack(side=\"left\", padx=6)\n",
    "\n",
    "        ttk.Button(ctrl, text=\"Close\", command=window.destroy).pack(side=\"right\")\n",
    "        # initially display page 1\n",
    "        display_page(1)\n",
    "\n",
    "    # ----------------------------\n",
    "    # Save / Save & Email\n",
    "    # ----------------------------\n",
    "    def save_master(self):\n",
    "        if self.master_df is None:\n",
    "            messagebox.showinfo(\"No data\", \"No merged data to save. Merge files first.\")\n",
    "            return\n",
    "        # ask where to save (default .xlsx)\n",
    "        initial_name = f\"master_{timestamp_suffix()}.xlsx\"\n",
    "        path = filedialog.asksaveasfilename(defaultextension=\".xlsx\", initialfile=initial_name, filetypes=[(\"Excel files\", \"*.xlsx\")])\n",
    "        if not path:\n",
    "            return\n",
    "        try:\n",
    "            safe_save_dataframe_to_excel(self.master_df, path)\n",
    "            # backup copy\n",
    "            if self.config.get(\"backups_enabled\", True):\n",
    "                create_backups_folder()\n",
    "                backup_name = f\"master_{timestamp_suffix()}.xlsx\"\n",
    "                backup_path = os.path.join(BACKUPS_DIR, backup_name)\n",
    "                safe_save_dataframe_to_excel(self.master_df, backup_path)\n",
    "                logger.info(\"Saved master to %s and backup to %s\", path, backup_path)\n",
    "            else:\n",
    "                logger.info(\"Saved master to %s (backups disabled)\", path)\n",
    "            messagebox.showinfo(\"Saved\", f\"Master file saved to:\\n{path}\")\n",
    "            self.last_action_label.config(text=f\"Last action: saved master to {os.path.basename(path)} at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n",
    "        except Exception as e:\n",
    "            logger.exception(\"Error saving master: %s\", e)\n",
    "            messagebox.showerror(\"Save error\", f\"Failed to save file: {e}\")\n",
    "\n",
    "    def save_and_email(self):\n",
    "        \"\"\"Save file (asks path) then prompt for recipients and send email in background.\"\"\"\n",
    "        if self.master_df is None:\n",
    "            messagebox.showinfo(\"No data\", \"No merged data to save & email. Merge files first.\")\n",
    "            return\n",
    "        initial_name = f\"master_{timestamp_suffix()}.xlsx\"\n",
    "        path = filedialog.asksaveasfilename(defaultextension=\".xlsx\", initialfile=initial_name, filetypes=[(\"Excel files\", \"*.xlsx\")])\n",
    "        if not path:\n",
    "            return\n",
    "        # Save first\n",
    "        try:\n",
    "            safe_save_dataframe_to_excel(self.master_df, path)\n",
    "            # backup\n",
    "            if self.config.get(\"backups_enabled\", True):\n",
    "                create_backups_folder()\n",
    "                backup_path = os.path.join(BACKUPS_DIR, os.path.basename(path).replace(\".xlsx\", f\"_{timestamp_suffix()}.xlsx\"))\n",
    "                safe_save_dataframe_to_excel(self.master_df, backup_path)\n",
    "            logger.info(\"Saved master for emailing: %s\", path)\n",
    "        except Exception as e:\n",
    "            logger.exception(\"Save for email failed: %s\", e)\n",
    "            messagebox.showerror(\"Save error\", f\"Failed to save master before email: {e}\")\n",
    "            return\n",
    "\n",
    "        # Ask recipients\n",
    "        recipients_str = simpledialog.askstring(\"Recipients\", \"Enter recipient emails (comma separated):\")\n",
    "        if recipients_str is None:\n",
    "            # user cancelled\n",
    "            return\n",
    "        recipients = [r.strip() for r in recipients_str.split(\",\") if r.strip()]\n",
    "        invalid = [r for r in recipients if not EMAIL_REGEX.match(r)]\n",
    "        if invalid:\n",
    "            messagebox.showerror(\"Invalid emails\", f\"The following emails are invalid:\\n{', '.join(invalid)}\")\n",
    "            return\n",
    "        # start background email send\n",
    "        t = threading.Thread(target=self._send_email_worker, args=(path, recipients), daemon=True)\n",
    "        t.start()\n",
    "\n",
    "    def _send_email_worker(self, path, recipients):\n",
    "        \"\"\"Background worker to send email; updates UI via queue.\"\"\"\n",
    "        self.queue.put((\"start_spinner\",))\n",
    "        self.queue.put((\"email_status\", f\"Sending email to {len(recipients)} recipients...\"))\n",
    "        logger.info(\"Sending email to %s (file: %s)\", recipients, path)\n",
    "        success_count = 0\n",
    "        failed = []\n",
    "\n",
    "        # choose method\n",
    "        try:\n",
    "            if self.config.get(\"use_gmail\", True):\n",
    "                # Using yagmail\n",
    "                sender = self.config.get(\"sender_email\", \"\")\n",
    "                app_password = self.config.get(\"app_password\", \"\")\n",
    "                if not sender or not app_password:\n",
    "                    raise RuntimeError(\"Gmail selected but sender_email or app_password not configured. Go to Settings and configure.\")\n",
    "                if yagmail is None:\n",
    "                    raise RuntimeError(\"yagmail not installed. Install yagmail or choose SMTP in Settings.\")\n",
    "                # yagmail will raise if failure\n",
    "                yag = yagmail.SMTP(user=sender, password=app_password)\n",
    "                yag.send(to=recipients, subject=EMAIL_SUBJECT, contents=EMAIL_BODY, attachments=path)\n",
    "                success_count = len(recipients)\n",
    "                failed = []\n",
    "            else:\n",
    "                # Generic SMTP\n",
    "                smtp_cfg = self.config.get(\"smtp\", {})\n",
    "                host = smtp_cfg.get(\"host\", \"\")\n",
    "                port = int(smtp_cfg.get(\"port\", 587))\n",
    "                username = smtp_cfg.get(\"username\", \"\")\n",
    "                password = smtp_cfg.get(\"password\", \"\")\n",
    "                use_tls = bool(smtp_cfg.get(\"use_tls\", True))\n",
    "                use_ssl = bool(smtp_cfg.get(\"use_ssl\", False))\n",
    "                if not host:\n",
    "                    raise RuntimeError(\"SMTP host not configured in Settings.\")\n",
    "                # Prepare message\n",
    "                msg = EmailMessage()\n",
    "                msg[\"Subject\"] = EMAIL_SUBJECT\n",
    "                msg[\"From\"] = username or self.config.get(\"sender_email\", \"\")\n",
    "                msg[\"To\"] = \", \".join(recipients)\n",
    "                msg.set_content(EMAIL_BODY)\n",
    "                # attach file\n",
    "                with open(path, \"rb\") as f:\n",
    "                    filedata = f.read()\n",
    "                # Attempt to set subtype intelligently\n",
    "                maintype = \"application\"\n",
    "                subtype = \"vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n",
    "                msg.add_attachment(filedata, maintype=maintype, subtype=subtype, filename=os.path.basename(path))\n",
    "                # Send\n",
    "                if use_ssl:\n",
    "                    server = smtplib.SMTP_SSL(host, port, timeout=30)\n",
    "                else:\n",
    "                    server = smtplib.SMTP(host, port, timeout=30)\n",
    "                server.ehlo()\n",
    "                if use_tls and not use_ssl:\n",
    "                    server.starttls()\n",
    "                if username and password:\n",
    "                    server.login(username, password)\n",
    "                server.send_message(msg)\n",
    "                server.quit()\n",
    "                success_count = len(recipients)\n",
    "                failed = []\n",
    "        except Exception as ex:\n",
    "            # Log error and show to user\n",
    "            logger.exception(\"Email sending failed: %s\", ex)\n",
    "            # Try to determine partial failures - in simple implementation we treat all as failed\n",
    "            failed = recipients\n",
    "            success_count = 0\n",
    "            # Put error message in queue\n",
    "            self.queue.put((\"email_status\", f\"Email failed: {ex}\"))\n",
    "            self.queue.put((\"email_result\", (success_count, failed)))\n",
    "            return\n",
    "\n",
    "        # On success:\n",
    "        self.queue.put((\"email_status\", \"Email sent.\"))\n",
    "        self.queue.put((\"email_result\", (success_count, failed)))\n",
    "        logger.info(\"Email send completed: sent=%d failed=%s\", success_count, failed)\n",
    "\n",
    "    # ----------------------------\n",
    "    # Settings dialog\n",
    "    # ----------------------------\n",
    "    def open_settings_dialog(self):\n",
    "        dlg = tk.Toplevel(self)\n",
    "        dlg.title(\"Settings\")\n",
    "        dlg.geometry(\"650x500\")\n",
    "        dlg.transient(self)\n",
    "\n",
    "        # Notebook style tabs: Email settings, Watch & backups\n",
    "        nb = ttk.Notebook(dlg)\n",
    "        nb.pack(fill=\"both\", expand=True, padx=8, pady=8)\n",
    "\n",
    "        # --- Email tab ---\n",
    "        frame_email = ttk.Frame(nb)\n",
    "        nb.add(frame_email, text=\"Email\")\n",
    "\n",
    "        use_gmail_var = tk.BooleanVar(value=self.config.get(\"use_gmail\", True))\n",
    "        ttk.Radiobutton(frame_email, text=\"Use Gmail (yagmail & App Password)\", variable=use_gmail_var, value=True).pack(anchor=\"w\", padx=8, pady=4)\n",
    "        ttk.Radiobutton(frame_email, text=\"Use Generic SMTP\", variable=use_gmail_var, value=False).pack(anchor=\"w\", padx=8, pady=(0,8))\n",
    "\n",
    "        gmail_frame = ttk.LabelFrame(frame_email, text=\"Gmail (yagmail)\")\n",
    "        gmail_frame.pack(fill=\"x\", padx=8, pady=6)\n",
    "\n",
    "        sender_var = tk.StringVar(value=self.config.get(\"sender_email\", \"\"))\n",
    "        sender_entry = ttk.Entry(gmail_frame, textvariable=sender_var, width=40)\n",
    "        ttk.Label(gmail_frame, text=\"Sender email:\").pack(anchor=\"w\", padx=6, pady=(6,0))\n",
    "        sender_entry.pack(anchor=\"w\", padx=6, pady=(0,6))\n",
    "\n",
    "        app_pass_var = tk.StringVar(value=self.config.get(\"app_password\", \"\"))\n",
    "        ttk.Label(gmail_frame, text=\"App password (or do not save, leave blank):\").pack(anchor=\"w\", padx=6)\n",
    "        app_pass_entry = ttk.Entry(gmail_frame, textvariable=app_pass_var, show=\"*\")\n",
    "        app_pass_entry.pack(anchor=\"w\", padx=6, pady=(0,6))\n",
    "\n",
    "        save_pass_var = tk.BooleanVar(value=self.config.get(\"save_password\", False))\n",
    "        ttk.Checkbutton(gmail_frame, text=\"Save password to config.json (NOT recommended)\", variable=save_pass_var).pack(anchor=\"w\", padx=6, pady=(0,6))\n",
    "\n",
    "        # generic smtp\n",
    "        smtp_frame = ttk.LabelFrame(frame_email, text=\"Generic SMTP\")\n",
    "        smtp_frame.pack(fill=\"x\", padx=8, pady=6)\n",
    "\n",
    "        smtp_host_var = tk.StringVar(value=self.config.get(\"smtp\", {}).get(\"host\", \"\"))\n",
    "        smtp_port_var = tk.IntVar(value=self.config.get(\"smtp\", {}).get(\"port\", 587))\n",
    "        smtp_user_var = tk.StringVar(value=self.config.get(\"smtp\", {}).get(\"username\", \"\"))\n",
    "        smtp_pass_var = tk.StringVar(value=self.config.get(\"smtp\", {}).get(\"password\", \"\"))\n",
    "        smtp_tls_var = tk.BooleanVar(value=self.config.get(\"smtp\", {}).get(\"use_tls\", True))\n",
    "        smtp_ssl_var = tk.BooleanVar(value=self.config.get(\"smtp\", {}).get(\"use_ssl\", False))\n",
    "\n",
    "        ttk.Label(smtp_frame, text=\"Host:\").grid(row=0, column=0, padx=6, pady=4, sticky=\"w\")\n",
    "        ttk.Entry(smtp_frame, textvariable=smtp_host_var, width=30).grid(row=0, column=1, padx=6, pady=4, sticky=\"w\")\n",
    "        ttk.Label(smtp_frame, text=\"Port:\").grid(row=0, column=2, padx=6, pady=4, sticky=\"w\")\n",
    "        ttk.Entry(smtp_frame, textvariable=smtp_port_var, width=8).grid(row=0, column=3, padx=6, pady=4, sticky=\"w\")\n",
    "\n",
    "        ttk.Label(smtp_frame, text=\"Username:\").grid(row=1, column=0, padx=6, pady=4, sticky=\"w\")\n",
    "        ttk.Entry(smtp_frame, textvariable=smtp_user_var, width=30).grid(row=1, column=1, padx=6, pady=4, sticky=\"w\")\n",
    "        ttk.Label(smtp_frame, text=\"Password:\").grid(row=1, column=2, padx=6, pady=4, sticky=\"w\")\n",
    "        ttk.Entry(smtp_frame, textvariable=smtp_pass_var, width=20, show=\"*\").grid(row=1, column=3, padx=6, pady=4, sticky=\"w\")\n",
    "\n",
    "        ttk.Checkbutton(smtp_frame, text=\"Use TLS\", variable=smtp_tls_var).grid(row=2, column=0, padx=6, pady=6, sticky=\"w\")\n",
    "        ttk.Checkbutton(smtp_frame, text=\"Use SSL\", variable=smtp_ssl_var).grid(row=2, column=1, padx=6, pady=6, sticky=\"w\")\n",
    "\n",
    "        # --- Watch & backups tab ---\n",
    "        frame_watch = ttk.Frame(nb)\n",
    "        nb.add(frame_watch, text=\"Watch & Backups\")\n",
    "\n",
    "        backups_var = tk.BooleanVar(value=self.config.get(\"backups_enabled\", True))\n",
    "        ttk.Checkbutton(frame_watch, text=\"Enable backups (save copies to backups/)\", variable=backups_var).pack(anchor=\"w\", padx=8, pady=6)\n",
    "\n",
    "        ttk.Label(frame_watch, text=\"Watch folder (optional):\").pack(anchor=\"w\", padx=8, pady=(6,0))\n",
    "        watch_path_var = tk.StringVar(value=self.config.get(\"watch_folder\", {}).get(\"path\", \"\"))\n",
    "        watch_entry = ttk.Entry(frame_watch, textvariable=watch_path_var, width=60)\n",
    "        watch_entry.pack(anchor=\"w\", padx=8, pady=(0,6))\n",
    "\n",
    "        def choose_watch_path():\n",
    "            p = filedialog.askdirectory(title=\"Choose folder to watch for new/modified Excel files\")\n",
    "            if p:\n",
    "                watch_path_var.set(p)\n",
    "\n",
    "        ttk.Button(frame_watch, text=\"Choose folder...\", command=choose_watch_path).pack(anchor=\"w\", padx=8, pady=(0,6))\n",
    "\n",
    "        watch_enable_var = tk.BooleanVar(value=self.config.get(\"watch_folder\", {}).get(\"enabled\", False))\n",
    "        ttk.Checkbutton(frame_watch, text=\"Enable watch folder on startup\", variable=watch_enable_var).pack(anchor=\"w\", padx=8, pady=4)\n",
    "\n",
    "        auto_email_var = tk.BooleanVar(value=self.config.get(\"watch_folder\", {}).get(\"auto_email_on_watch\", False))\n",
    "        ttk.Checkbutton(frame_watch, text=\"Auto-email when watch triggers (use recipients below)\", variable=auto_email_var).pack(anchor=\"w\", padx=8, pady=4)\n",
    "\n",
    "        ttk.Label(frame_watch, text=\"Auto-email recipients (comma separated):\").pack(anchor=\"w\", padx=8, pady=(6,0))\n",
    "        auto_recipients_var = tk.StringVar(value=self.config.get(\"watch_folder\", {}).get(\"auto_email_recipients\", \"\"))\n",
    "        ttk.Entry(frame_watch, textvariable=auto_recipients_var, width=60).pack(anchor=\"w\", padx=8, pady=(0,6))\n",
    "\n",
    "        # page size default\n",
    "        ttk.Label(frame_watch, text=\"Default page size for full view:\").pack(anchor=\"w\", padx=8, pady=(6,0))\n",
    "        page_size_default_var = tk.IntVar(value=self.config.get(\"page_size_default\", DEFAULT_PAGE_SIZE))\n",
    "        ttk.Spinbox(frame_watch, from_=10, to=5000, textvariable=page_size_default_var, width=10).pack(anchor=\"w\", padx=8, pady=(0,6))\n",
    "\n",
    "        # Save/Cancel buttons\n",
    "        btn_frame = ttk.Frame(dlg)\n",
    "        btn_frame.pack(side=\"bottom\", fill=\"x\", padx=8, pady=8)\n",
    "        def on_save_settings():\n",
    "            # gather settings\n",
    "            self.config[\"use_gmail\"] = bool(use_gmail_var.get())\n",
    "            self.config[\"sender_email\"] = sender_var.get().strip()\n",
    "            if save_pass_var.get():\n",
    "                # user chose to save password\n",
    "                self.config[\"app_password\"] = app_pass_var.get()\n",
    "            else:\n",
    "                # clear saved password if user chooses not to save\n",
    "                self.config[\"app_password\"] = \"\" if not self.config.get(\"save_password\", False) else self.config.get(\"app_password\", \"\")\n",
    "            self.config[\"save_password\"] = bool(save_pass_var.get())\n",
    "\n",
    "            self.config[\"smtp\"][\"host\"] = smtp_host_var.get().strip()\n",
    "            self.config[\"smtp\"][\"port\"] = int(smtp_port_var.get())\n",
    "            self.config[\"smtp\"][\"username\"] = smtp_user_var.get().strip()\n",
    "            self.config[\"smtp\"][\"password\"] = smtp_pass_var.get()\n",
    "            self.config[\"smtp\"][\"use_tls\"] = bool(smtp_tls_var.get())\n",
    "            self.config[\"smtp\"][\"use_ssl\"] = bool(smtp_ssl_var.get())\n",
    "\n",
    "            self.config[\"backups_enabled\"] = bool(backups_var.get())\n",
    "            self.config[\"watch_folder\"][\"enabled\"] = bool(watch_enable_var.get())\n",
    "            self.config[\"watch_folder\"][\"path\"] = watch_path_var.get().strip()\n",
    "            self.config[\"watch_folder\"][\"auto_email_on_watch\"] = bool(auto_email_var.get())\n",
    "            self.config[\"watch_folder\"][\"auto_email_recipients\"] = auto_recipients_var.get().strip()\n",
    "            self.config[\"page_size_default\"] = int(page_size_default_var.get())\n",
    "\n",
    "            # Save to disk\n",
    "            save_config(self.config)\n",
    "            # update page size var live\n",
    "            try:\n",
    "                self.page_size_var.set(int(page_size_default_var.get()))\n",
    "            except Exception:\n",
    "                pass\n",
    "\n",
    "            # if watch enabled, start/stop appropriately\n",
    "            if self.config[\"watch_folder\"][\"enabled\"]:\n",
    "                path_to_watch = self.config[\"watch_folder\"][\"path\"]\n",
    "                if path_to_watch:\n",
    "                    try:\n",
    "                        self.start_watch(path_to_watch)\n",
    "                    except Exception as e:\n",
    "                        logger.exception(\"Failed starting watch: %s\", e)\n",
    "                        messagebox.showerror(\"Watch error\", f\"Failed to start watch: {e}\")\n",
    "                else:\n",
    "                    messagebox.showwarning(\"Watch\", \"Watch enabled but no folder path provided.\")\n",
    "            else:\n",
    "                if self._watching:\n",
    "                    self.stop_watch()\n",
    "\n",
    "            dlg.destroy()\n",
    "            messagebox.showinfo(\"Settings\", \"Settings saved.\")\n",
    "        ttk.Button(btn_frame, text=\"Save\", command=on_save_settings).pack(side=\"right\", padx=6)\n",
    "        ttk.Button(btn_frame, text=\"Cancel\", command=dlg.destroy).pack(side=\"right\")\n",
    "\n",
    "    # ----------------------------\n",
    "    # Watch folder control functions\n",
    "    # ----------------------------\n",
    "    def choose_watch_folder(self):\n",
    "        p = filedialog.askdirectory(title=\"Select folder to watch for new/modified Excel files\")\n",
    "        if p:\n",
    "            self.config[\"watch_folder\"][\"path\"] = p\n",
    "            save_config(self.config)\n",
    "            self.status_label.config(text=f\"Watch folder set: {p}\")\n",
    "\n",
    "    def on_watch_toggle(self):\n",
    "        enabled = self.watch_var.get()\n",
    "        self.config[\"watch_folder\"][\"enabled\"] = bool(enabled)\n",
    "        save_config(self.config)\n",
    "        if enabled:\n",
    "            path = self.config.get(\"watch_folder\", {}).get(\"path\", \"\")\n",
    "            if not path:\n",
    "                messagebox.showinfo(\"Watch Folder\", \"Please choose a watch folder first (Choose Watch Folder button).\")\n",
    "                self.watch_var.set(False)\n",
    "                self.config[\"watch_folder\"][\"enabled\"] = False\n",
    "                save_config(self.config)\n",
    "                return\n",
    "            if Observer is None:\n",
    "                messagebox.showerror(\"Watch folder unavailable\", \"watchdog package is not installed. Install it with `pip install watchdog` to use watch mode.\")\n",
    "                self.watch_var.set(False)\n",
    "                self.config[\"watch_folder\"][\"enabled\"] = False\n",
    "                save_config(self.config)\n",
    "                return\n",
    "            try:\n",
    "                self.start_watch(path)\n",
    "                messagebox.showinfo(\"Watch\", f\"Started watching: {path}\")\n",
    "            except Exception as e:\n",
    "                logger.exception(\"Failed to start watch: %s\", e)\n",
    "                messagebox.showerror(\"Watch error\", f\"Failed to start watching folder: {e}\")\n",
    "        else:\n",
    "            self.stop_watch()\n",
    "            messagebox.showinfo(\"Watch\", \"Watch stopped.\")\n",
    "\n",
    "    def start_watch(self, path):\n",
    "        \"\"\"Start watchdog observer in background.\"\"\"\n",
    "        if Observer is None:\n",
    "            raise RuntimeError(\"watchdog not available (pip install watchdog).\")\n",
    "        if not os.path.isdir(path):\n",
    "            raise RuntimeError(\"Path is not a directory.\")\n",
    "        if self._watching:\n",
    "            # stop previous\n",
    "            self.stop_watch()\n",
    "        self.watch_handler = ExcelWatchHandler(self)\n",
    "        self.watch_observer = Observer()\n",
    "        self.watch_observer.schedule(self.watch_handler, path, recursive=False)\n",
    "        self.watch_observer.start()\n",
    "        self._watching = True\n",
    "        logger.info(\"Watch started on %s\", path)\n",
    "        self.status_label.config(text=f\"Watching: {path}\")\n",
    "\n",
    "    def stop_watch(self):\n",
    "        try:\n",
    "            if self.watch_observer:\n",
    "                self.watch_observer.stop()\n",
    "                self.watch_observer.join(timeout=2)\n",
    "        except Exception:\n",
    "            pass\n",
    "        self.watch_observer = None\n",
    "        self.watch_handler = None\n",
    "        self._watching = False\n",
    "        logger.info(\"Watch stopped.\")\n",
    "        self.status_label.config(text=\"Watch stopped.\")\n",
    "\n",
    "    def handle_watch_event(self, path):\n",
    "        \"\"\"Triggered when watchdog queue reports a new/modified excel file.\"\"\"\n",
    "        # Behavior: if watch triggers, merge all files in folder that match extension\n",
    "        folder = os.path.dirname(path)\n",
    "        self.status_label.config(text=f\"Watch triggered by {os.path.basename(path)}\")\n",
    "        # gather all xlsx/xls files in folder\n",
    "        files = [os.path.join(folder, f) for f in os.listdir(folder) if f.lower().endswith((\".xlsx\", \".xls\"))]\n",
    "        files.sort()\n",
    "        # set selected files to the full list and merge\n",
    "        self.selected_files = files\n",
    "        logger.info(\"Watch merging %d files from %s\", len(files), folder)\n",
    "        # Start merge\n",
    "        t = threading.Thread(target=self._merge_worker, args=(files,), daemon=True)\n",
    "        t.start()\n",
    "        # If auto-email enabled, send after merge completes (merge will set self.master_df)\n",
    "        # We'll spawn a watcher thread that waits for merge completion then sends\n",
    "        if self.config.get(\"watch_folder\", {}).get(\"auto_email_on_watch\", False):\n",
    "            recipients_str = self.config.get(\"watch_folder\", {}).get(\"auto_email_recipients\", \"\")\n",
    "            if recipients_str.strip():\n",
    "                recipients = [r.strip() for r in recipients_str.split(\",\") if r.strip()]\n",
    "                # Wait for merge to complete in background and then send\n",
    "                def wait_and_send():\n",
    "                    # naive polling for master_df population\n",
    "                    # Wait up to 60 seconds for merge to complete\n",
    "                    waited = 0\n",
    "                    while waited < 60:\n",
    "                        if self.master_df is not None and len(self.master_df) > 0:\n",
    "                            break\n",
    "                        time.sleep(1)\n",
    "                        waited += 1\n",
    "                    # If we have master_df, save to a backup file and send email\n",
    "                    if self.master_df is None:\n",
    "                        logger.warning(\"Auto-email: merge did not complete in time.\")\n",
    "                        return\n",
    "                    create_backups_folder()\n",
    "                    auto_path = os.path.join(BACKUPS_DIR, f\"auto_master_{timestamp_suffix()}.xlsx\")\n",
    "                    try:\n",
    "                        safe_save_dataframe_to_excel(self.master_df, auto_path)\n",
    "                        logger.info(\"Auto-email saved merged file to %s\", auto_path)\n",
    "                        # send email using same worker\n",
    "                        self._send_email_worker(auto_path, recipients)\n",
    "                    except Exception as ex:\n",
    "                        logger.exception(\"Auto-email flow failed: %s\", ex)\n",
    "                threading.Thread(target=wait_and_send, daemon=True).start()\n",
    "            else:\n",
    "                logger.warning(\"Auto-email enabled but no recipients configured.\")\n",
    "\n",
    "    # ----------------------------\n",
    "    # Backups folder opener\n",
    "    # ----------------------------\n",
    "    def open_backups_folder(self):\n",
    "        if not os.path.exists(BACKUPS_DIR):\n",
    "            messagebox.showinfo(\"Backups\", \"No backups folder exists yet.\")\n",
    "            return\n",
    "        open_folder(BACKUPS_DIR)\n",
    "\n",
    "# ----------------------------\n",
    "# CLI / run\n",
    "# ----------------------------\n",
    "def ensure_requirements_hint():\n",
    "    missing = []\n",
    "    try:\n",
    "        import pandas  # noqa\n",
    "    except Exception:\n",
    "        missing.append(\"pandas\")\n",
    "    if yagmail is None:\n",
    "        # not required, but recommended\n",
    "        pass\n",
    "    if Observer is None:\n",
    "        pass\n",
    "    return missing\n",
    "\n",
    "def main():\n",
    "    missing = ensure_requirements_hint()\n",
    "    if missing:\n",
    "        msg = \"Some required packages appear to be missing: \" + \", \".join(missing)\n",
    "        print(msg)\n",
    "    app = ExcelMergeApp()\n",
    "    app.mainloop()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
